\documentclass{article}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\lstset{
language=Java,                  % the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                % will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=t,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
}

\begin{document}

\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}

\title{Knowledge Representation \& Reasoning: LK Calculus Reasoner}
\author{Luke Slater (luke.slater.1@kaust.edu.sa)}

\maketitle

\pagebreak

\section{Implementation}

The basic LK system has been implemented with all logical and structural rules,
discluding the cut rule and those involving quantifiers. It is implemented in
Javascript. In retrospect, I should not have implemented an undecidable problem in
Javascript. Javascript is not an appropriate language for logical argument
deduction.

The algorithm uses a breadth-first search to incrementally consider all possible
expansion options until reaching the axiom (A $\vdash$ A) for all subformulas in
the given track. I use subformula to mean each of the formulae which must be
solved to create a proof for the initial formula (so initially there will be
one, and more will be created in the case that a rule which creates two formulas
e.g. IL is run). The basic algorithm is like so:

\begin{enumerate}
  \item Create a set of tracks, and add the initial formula.
  \item Iterate all tracks
    \begin{enumerate}
      \item Iterate subformulas and apply all rules.
      \item Create a new track for each applicable rule (including a track for each 
      possible combination of subformula result). If one of the new tracks
      consists only of subformulas which are the axiom, print proof and exit.
    \end{enumerate}
  \item Replace the set of tracks with the new tracks generated by the current
  round.
\end{enumerate}

The implementation operates on lists of symbols, which are modelled internally
by arrays - one for each side of the sequent. Operations are represented in
object notation - and these representations are also required as the input
format due to the difficulty of parsing prefix or infix logical notation in
Javascript. These representations are, however, converted to infix notation for
the output stage. Each of the rules has its own function, which checks the item
closest to the sequent on its respective side for a match, and transforms it if
possible (and also returns additional subformulas or results if this is
necessary).

\section{Hilbert Calculus Proofs}

\begin{lstlisting}[mathescape=true,title=Axiom 1 Proof]
 Step 0
 Formula 0
   Operation: IN
   Value:  $\vdash$ A $\Rightarrow$ A
 Step 1
 Formula 0
   Operation: IR
   Value: A $\vdash$ A
\end{lstlisting}

\begin{lstlisting}[mathescape=true,title=Axiom 2 Proof]
 Step 0
 Formula 0
   Operation: IN
   Value:  $\vdash$ A $\Rightarrow$ (B $\Rightarrow$ A)
 Step 1
 Formula 0
   Operation: IR
   Value: A $\vdash$ B $\Rightarrow$ A
 Step 2
 Formula 0
   Operation: IR
   Value: A, B $\vdash$ A
 Step 3
 Formula 0
   Operation: WL
   Value: A $\vdash$ A
\end{lstlisting}

\begin{lstlisting}[mathescape=true,title=Axiom 4 Proof]
 Step 0
 Formula 0
   Operation: IN
   Value:  $\vdash$ (($\neg$A) $\Rightarrow$ ($\neg$B)) $\Rightarrow$ (B $\Rightarrow$ A)
 Step 1
 Formula 0
   Operation: IR
   Value: ($\neg$A) $\Rightarrow$ ($\neg$B) $\vdash$ B $\Rightarrow$ A
 Step 2
 Formula 0
   Operation: IR
   Value: ($\neg$A) $\Rightarrow$ ($\neg$B), B $\vdash$ A
 Step 3
 Formula 0
   Operation: PL
   Value: B, ($\neg$A) $\Rightarrow$ ($\neg$B) $\vdash$ A
 Step 4
 Formula 0
   Operation: IL
   Value:  $\vdash$ $\neg$A, A
 Formula 1
   Operation: IL
   Value: B, $\neg$B $\vdash$ 
 Step 5
 Formula 0
   Operation: NR
   Value: A $\vdash$ A
 Formula 1
   Operation: NL
   Value: B $\vdash$ B
\end{lstlisting}

\begin{lstlisting}[mathescape=true,title=Axiom 4m Proof]
 Step 0
 Formula 0
   Operation: IN
   Value:  $\vdash$ (A $\Rightarrow$ B) $\Rightarrow$ ((A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A))
 Step 1
 Formula 0
   Operation: IR
   Value: A $\Rightarrow$ B $\vdash$ (A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A)
 Step 2
 Formula 0
   Operation: CR
   Value: A $\Rightarrow$ B $\vdash$ (A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A), (A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A)
 Step 3
 Formula 0
   Operation: IL
   Value:  $\vdash$ A, (A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A)
 Formula 1
   Operation: IL
   Value: B $\vdash$ (A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A)
 Step 4
 Formula 0
   Operation: PR
   Value:  $\vdash$ (A $\Rightarrow$ ($\neg$B)) $\Rightarrow$ ($\neg$A), A
 Formula 1
   Operation: IR
   Value: B, A $\Rightarrow$ ($\neg$B) $\vdash$ $\neg$A
 Step 5
 Formula 0
   Operation: IR
   Value: A $\Rightarrow$ ($\neg$B) $\vdash$ $\neg$A, A
 Formula 1
   Operation: IL
   Value:  $\vdash$ A, $\neg$A
 Formula 2
   Operation: IL
   Value: B, $\neg$B $\vdash$ 
 Step 6
 Formula 0
   Operation: WL
   Value:  $\vdash$ $\neg$A, A
 Formula 1
   Operation: PR
   Value:  $\vdash$ $\neg$A, A
 Formula 2
   Operation: CR
   Value: B, $\neg$B $\vdash$ 
 Step 7
 Formula 0
   Operation: NR
   Value: A $\vdash$ A
 Formula 1
   Operation: NR
   Value: A $\vdash$ A
 Formula 2
   Operation: NL
   Value: B $\vdash$ B
\end{lstlisting}

\section{Semantic Entailment}

\section{Modus Ponens}

\begin{lstlisting}[mathescape=true,title=Modus Ponens Proof]
 Step 0
 Formula 0
   Operation: IN
   Value: A $\Rightarrow$ B, A $\vdash$ B
 Step 1
 Formula 0
   Operation: PL
   Value: A, A $\Rightarrow$ B $\vdash$ B
 Step 2
 Formula 0
   Operation: IL
   Value: A $\vdash$ A
 Formula 1
   Operation: IL
   Value: B $\vdash$ B
\end{lstlisting}

\section{Time Complexity}

The implementation is undecidable, and so it is very difficult to calculate the
time complexity - there is no lower bound. The best one
can say is that if there is a proof to be found, then given unlimited time and
unlimited resources, it will eventually be found.

The growth of the number of tracks which must be evaluated at every step of the 
breadth first search increases exponentially, but the degree of growth is highly 
dependent on the input. 

The reason for this is that the application of certain rules leads to a massive
number of new potential tracks compared to others. These particularly explosive
rules are those which lead to multiple formulas e.g. IL. They lead to many new
tracks initially because one must create a new track for every possible manner
of distributing the remaining symbols in the formula between the two resulting
formulas, and in subsequent steps because one must create new tracks for every
combination of every possible rule applicable to every subformula in a given
track repeatedly.

This issue is particularly apparent while trying to prove the Hilbert calculus
axioms, which rely on nested implications - leading to several applications of
the IL rule.

\section{Performance Optimisation}

It seems that there are many potential performance enhancements which could be
applied to attempt to improve the performance of the calculus prover. 

\subsection{Implemented Improvements}

In the
methods I have attempted, the focus has been on reducing the number of track
growth between steps of the search:

\begin{itemize}
  \item Remove dead tracks: these are tracks with subformulas without any
  possible solutions, such as:
  \begin{itemize}
    \item $\vdash$ A
    \item Empty set both sides of the sequent
    \item Total of one symbol on both sides of the sequent
  \end{itemize}

  \item Limitation of structural rules; many unhelpful tracks were being generated by
  the constant application of structural rules, so these were limited. The
  following cases were disallowed:
  \begin{itemize}
    \item The last rule was CR and the current rule is WR
    \item The last rule was CR and the current rule is CR
    \item The last rule was PR and the current rule is CR
    \item The last rule was PR and the current rule is WR
    \item The last rule was CL and the current rule is WL
    \item The last rule was CL and the current rule is CL
    \item The last rule was PL and the current rule is CL
    \item The last rule was PL and the current rule is WL
  \end{itemize}

  \item Remove tracks which are ten items longer than the initial formula, since
  this probably means that the structural rules have run away with the formula
  and aren't moving towards a constructive solution.
\end{itemize}

I think that there is potential that some of these rules could prevent the
discovery of proofs in some cases - particularly the limitation of repeated
structural rules in the case of more complicated formulas. However, I did not
come accross any such problems during testing and they can easily be disabled.

\subsection{Structural Rules}

Given more time to rewrite the system to be a bit more flexible, I think that a
major improvement could be to disallow the use of structural rules entirely,
until it has been found that there is no possible solution to be found by the
application of logical rules only. It should be possible to traverse all
possibilities, since the LK system without structural rules should terminate.

The main difficulty here is to implement
effective backtracking, figuring out where to start applying structural rules
in the case of a dead path. It might seem like the better option to start
applying structural rules from the last non-dead step, but this will cause
problems. Take the example of the Law of Excluded Middle
($\vdash$ A $\vee$ $\neg$A), the proof for which requires an application of the
CR rule as the first step - it is possible to apply a maximum of two steps
before exhausting logical rule possibilities (in the case we use OR2 and NR).

Thus, a solution would have to attempt to find a solution using only logical
rules, and upon failure apply structural rules on the first step, potentially
leading to many more sub-problems than is actually necessary.

I think the superior solution would be to implement a modified version of the LK
system which operates on sets rather than lists. This works because we know
that the contraction and permutation rules mean the order and number of symbols
in the sequence don't matter, and cannot prevent a valid proof being found.

Furthermore, many implementations of LK calculus also use 'weakening,' which
allows the addition of arbitrary elements to the set of formulae. This too
allows us to assume a proof (in which a formula is considered equivalent to A
$\vdash$ A) without the use of structural rules. This also leads to shorter
proofs.

\subsection{Existing Performance Issues}

While track growth can be limited by the modification or elimination of
structural rules, it does not eliminate the problem. The major performance 
issues with the presented implementation are twofold, and both stem from the 
exponential growth of the number of tracks which need to be processed.

The first is that a situation quickly arises in which there are too many tracks
to process. Some of the methods noted above attempt to reduce the amount of
unnecessary tracks generated, but it is still severely limiting. The current
implementation is single-threaded, and an alternative solution in Groovy or
similar would implement multi-threading to allow tracks to be evaluated by all
cores.

Another issue which arises from the track growth in combination with the data
model used, is that the RAM quickly grows to become out of control. The primary
reason for this is that each track stores its entire history from step zero -
when there are lots of tracks, this means a substantial amount of unnecessarily
duplicated memory. It was implemented this way originally because it makes 
printing the eventual proof easy; in an improved solution, track histories would
be stored only once, and each current track would just have a pointer to its
corresponding history.

\end{document}
